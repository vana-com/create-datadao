const fs = require('fs-extra');
const path = require('path');
const { execSync } = require('child_process');
const chalk = require('chalk');
const ora = require('ora');
const { createPublicClient, http } = require('viem');
const { moksha } = require('viem/chains');

/**
 * Check wallet balance before deployment
 */
async function checkWalletBalance(address) {
  const client = createPublicClient({
    chain: moksha,
    transport: http('https://rpc.moksha.vana.org')
  });

  try {
    const balance = await client.getBalance({ address });
    const balanceInVana = Number(balance) / 1e18;

    console.log(chalk.blue('💰 Wallet Information:'));
    console.log(`  Address: ${address}`);
    console.log(`  Balance: ${balanceInVana.toFixed(4)} VANA`);
    console.log();

    if (balanceInVana < 0.1) {
      console.error(chalk.red('❌ Insufficient balance for deployment!'));
      console.error(chalk.yellow('Please fund your wallet with at least 0.1 VANA from https://faucet.vana.org'));
      console.error(chalk.yellow(`Your wallet address: ${address}`));
      process.exit(1);
    }

    console.log(chalk.green('✅ Wallet has sufficient balance for deployment'));
    return balanceInVana;
  } catch (error) {
    console.error(chalk.yellow(`⚠️  Could not check wallet balance: ${error.message}`));
    console.log(chalk.yellow('Proceeding with deployment...'));
    return null;
  }
}

/**
 * Deploy smart contracts
 */
async function deployContracts() {
  console.log(chalk.blue('Deploying smart contracts...'));

  try {
    // Load deployment info to get wallet address
    const deploymentPath = path.resolve('deployment.json');
    const deployment = JSON.parse(fs.readFileSync(deploymentPath, 'utf8'));

    // Check wallet balance first
    await checkWalletBalance(deployment.address);

    // Change to contracts directory
    process.chdir('contracts');

    // Deploy contracts using hardhat with spinner
    const spinner = ora({
      text: 'Running hardhat deployment...\n' +
            chalk.yellow('💡 This usually takes 2-5 minutes depending on network conditions\n') +
            chalk.gray('   • Compiling contracts\n') +
            chalk.gray('   • Deploying to Moksha testnet\n') +
            chalk.gray('   • Verifying on block explorer'),
      spinner: 'dots'
    }).start();

    let output;
    try {
      output = execSync('npx hardhat deploy --network moksha --tags DLPDeploy', {
        encoding: 'utf8',
        stdio: 'pipe'
      });
      spinner.succeed(chalk.green('✅ Hardhat deployment completed successfully!'));
    } catch (deployError) {
      spinner.fail(chalk.red('❌ Hardhat deployment failed'));
      throw deployError;
    }

    console.log();
    console.log(chalk.cyan('📋 Deployment Output:'));
    console.log(output);

    // Extract contract addresses from output - updated patterns for vana-smart-contracts
    const tokenMatch = output.match(/(?:Token|DAT).*?(?:deployed|reusing).*?(?:at|to)\s+(0x[a-fA-F0-9]{40})/i);
    const dlpMatch = output.match(/(?:DataLiquidityPool|DLP).*?(?:deployed|reusing).*?(?:at|to)\s+(0x[a-fA-F0-9]{40})/i);
    const vestingMatch = output.match(/(?:Vesting|VestingWallet).*?(?:deployed|reusing).*?(?:at|to)\s+(0x[a-fA-F0-9]{40})/i);

    if (!tokenMatch) {
      console.error(chalk.red('Error: Failed to extract token address from deployment output.'));
      console.error(chalk.yellow('Please check deployment logs above for contract addresses.'));
      console.error(chalk.yellow('You may need to manually extract addresses from the output.'));
      process.exit(1);
    }

    const tokenAddress = tokenMatch[1];

    // Update deployment.json with state management
    deployment.tokenAddress = tokenAddress;
    deployment.state = deployment.state || {};
    deployment.state.contractsDeployed = true;

    console.log(chalk.green('✅ Contracts deployed successfully!'));
    console.log(chalk.cyan('Token Address:'), tokenAddress);

    if (dlpMatch) {
      const dlpAddress = dlpMatch[1];
      deployment.dlpAddress = dlpAddress;
      console.log(chalk.cyan('DLP Address:'), dlpAddress);
    }

    if (vestingMatch) {
      const vestingAddress = vestingMatch[1];
      deployment.vestingAddress = vestingAddress;
      console.log(chalk.cyan('Vesting Address:'), vestingAddress);
    }

    fs.writeFileSync(deploymentPath, JSON.stringify(deployment, null, 2));

  } catch (error) {
    console.error(chalk.red('Contract deployment failed:'));
    console.error(error.message);

    // Check if it's a known error type
    if (error.message.includes('insufficient funds') || error.message.includes('INSUFFICIENT_FUNDS')) {
      console.error(chalk.yellow('💡 This appears to be a funding issue.'));
      console.error(chalk.yellow('Please ensure your wallet has sufficient VANA tokens.'));
    } else if (error.message.includes('execution reverted')) {
      console.error(chalk.yellow('💡 Transaction was reverted by the network.'));
      console.error(chalk.yellow('This could be due to:'));
      console.error(chalk.yellow('  - Insufficient gas or funds'));
      console.error(chalk.yellow('  - Contract deployment restrictions'));
      console.error(chalk.yellow('  - Network congestion'));
    }

    console.error(chalk.yellow('\nTroubleshooting:'));
    console.error(chalk.yellow('1. Check your wallet balance at https://moksha.vanascan.io'));
    console.error(chalk.yellow('2. Get more VANA from https://faucet.vana.org'));
    console.error(chalk.yellow('3. Wait a few minutes and try again'));

    process.exit(1);
  }
}

// Run deployment
deployContracts(); 