const fs = require('fs-extra');
const path = require('path');
const chalk = require('chalk');
const inquirer = require('inquirer');
const { createPublicClient, createWalletClient, http, parseEther } = require('viem');
const { privateKeyToAccount } = require('viem/accounts');
const { moksha } = require('viem/chains');

// DLP Registry contract address and ABI
const DLP_REGISTRY_ADDRESS = '{{DLP_REGISTRY_CONTRACT_ADDRESS}}';
const DLP_REGISTRY_ABI = [
  {
    "inputs": [{"internalType": "address", "name": "dlpAddress", "type": "address"}],
    "name": "dlpIds",
    "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "dlpAddress",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "ownerAddress",
            "type": "address"
          },
          {
            "internalType": "address payable",
            "name": "treasuryAddress",
            "type": "address"
          },
          {
            "internalType": "string",
            "name": "name",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "iconUrl",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "website",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "metadata",
            "type": "string"
          }
        ],
        "internalType": "struct IDLPRegistry.DlpRegistration",
        "name": "registrationInfo",
        "type": "tuple"
      }
    ],
    "name": "registerDlp",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  }
];

/**
 * Get dlpId from the registry automatically
 */
async function getDlpId(dlpAddress) {
  const client = createPublicClient({
    chain: moksha,
    transport: http('{{MOKSHA_RPC_URL}}')
  });

  try {
    const dlpId = await client.readContract({
      address: DLP_REGISTRY_ADDRESS,
      abi: DLP_REGISTRY_ABI,
      functionName: 'dlpIds',
      args: [dlpAddress]
    });

    return Number(dlpId);
  } catch (error) {
    console.error(chalk.red('Error querying dlpId:'), error.message);
    return 0;
  }
}

/**
 * Check wallet balance before registration
 */
async function checkWalletBalance(address) {
  const client = createPublicClient({
    chain: moksha,
    transport: http('{{MOKSHA_RPC_URL}}')
  });

  try {
    const balance = await client.getBalance({ address });
    const balanceInVana = Number(balance) / 1e18;

    console.log(chalk.blue('üí∞ Wallet Information:'));
    console.log(`  Address: ${address}`);
    console.log(`  Balance: ${balanceInVana.toFixed(4)} VANA`);
    console.log();

    if (balanceInVana < 1.1) {
      console.error(chalk.red('‚ùå Insufficient balance for registration!'));
      console.error(chalk.yellow('Registration requires 1 VANA + gas fees (recommend at least 1.1 VANA)'));
      console.error(chalk.yellow('Please fund your wallet from https://faucet.vana.org'));
      console.error(chalk.yellow(`Your wallet address: ${address}`));
      return false;
    }

    console.log(chalk.green('‚úÖ Wallet has sufficient balance for registration'));
    return true;
  } catch (error) {
    console.error(chalk.yellow(`‚ö†Ô∏è  Could not check wallet balance: ${error.message}`));
    console.log(chalk.yellow('Proceeding with registration...'));
    return true;
  }
}

/**
 * ENHANCEMENT: Perform automated registration
 */
async function performAutomatedRegistration(deployment) {
  console.log(chalk.blue('‚ö° Starting automated registration...'));
  console.log();

  // Load private key from contracts .env
  const contractsEnvPath = path.join(process.cwd(), 'contracts', '.env');
  if (!fs.existsSync(contractsEnvPath)) {
    console.error(chalk.red('No contracts/.env file found. Cannot access private key.'));
    return false;
  }

  const envContent = fs.readFileSync(contractsEnvPath, 'utf8');
  const privateKeyMatch = envContent.match(/DEPLOYER_PRIVATE_KEY=(.+)/);

  if (!privateKeyMatch) {
    console.error(chalk.red('No DEPLOYER_PRIVATE_KEY found in contracts/.env'));
    return false;
  }

  const privateKey = privateKeyMatch[1].trim();

  try {
    // Create account and clients
    const account = privateKeyToAccount(privateKey);

    const publicClient = createPublicClient({
      chain: moksha,
      transport: http('{{MOKSHA_RPC_URL}}')
    });

    const walletClient = createWalletClient({
      account,
      chain: moksha,
      transport: http('{{MOKSHA_RPC_URL}}')
    });

    // Check balance
    const hasBalance = await checkWalletBalance(account.address);
    if (!hasBalance) {
      return false;
    }

    // Get the DLP proxy address (supports both old and new format)
    const dlpProxyAddress = deployment.proxyAddress || 
                           (deployment.contracts && deployment.contracts.proxyAddress) ||
                           deployment.dlpAddress;
                           
    if (!dlpProxyAddress) {
      console.error(chalk.red('‚ùå DLP proxy address not found in deployment.json'));
      console.error(chalk.yellow('Please ensure contracts are deployed first.'));
      return false;
    }
    
    // Prepare registration parameters
    const registrationParams = {
      dlpAddress: dlpProxyAddress,
      ownerAddress: deployment.address,
      treasuryAddress: deployment.address,
      name: deployment.dlpName,
      iconUrl: '',
      website: '',
      metadata: ''
    };

    console.log(chalk.blue('üìã Registration Parameters:'));
    console.log(`  DLP Address: ${registrationParams.dlpAddress}`);
    console.log(`  Owner: ${registrationParams.ownerAddress}`);
    console.log(`  Treasury: ${registrationParams.treasuryAddress}`);
    console.log(`  Name: ${registrationParams.name}`);
    console.log(`  Registration Fee: 1 VANA`);
    console.log();

    const { confirm } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'confirm',
        message: 'Proceed with automated registration?',
        default: true
      }
    ]);

    if (!confirm) {
      console.log(chalk.yellow('Registration cancelled.'));
      return false;
    }

    console.log(chalk.blue('üöÄ Submitting registration transaction...'));

    // Call registerDlp function
    const hash = await walletClient.writeContract({
      address: DLP_REGISTRY_ADDRESS,
      abi: DLP_REGISTRY_ABI,
      functionName: 'registerDlp',
      args: [
        {
          dlpAddress: registrationParams.dlpAddress,
          ownerAddress: registrationParams.ownerAddress,
          treasuryAddress: registrationParams.treasuryAddress,
          name: registrationParams.name,
          iconUrl: registrationParams.iconUrl,
          website: registrationParams.website,
          metadata: registrationParams.metadata
        }
      ],
      value: parseEther('1') // 1 VANA registration fee
    });

    console.log(chalk.blue(`üìù Transaction submitted: ${hash}`));
    console.log(chalk.blue('‚è≥ Waiting for confirmation...'));

    // Wait for transaction receipt
    const receipt = await publicClient.waitForTransactionReceipt({ hash });

    if (receipt.status === 'success') {
      console.log(chalk.green('‚úÖ Registration transaction confirmed!'));
      console.log(`   Block: ${receipt.blockNumber}`);
      console.log(`   Gas used: ${receipt.gasUsed}`);
      console.log();

      // Get the dlpId
      console.log(chalk.blue('üîç Retrieving dlpId...'));
      const dlpId = await getDlpId(dlpProxyAddress);

      if (dlpId > 0) {
        console.log(chalk.green(`‚úÖ Registration successful! dlpId: ${dlpId}`));
        deployment.dlpId = dlpId;
        deployment.state = deployment.state || {};
        deployment.state.dataDAORegistered = true;
        return true;
      } else {
        console.error(chalk.red('Registration transaction succeeded but could not retrieve dlpId'));
        console.log(chalk.yellow('Please check the transaction and try querying dlpId manually'));
        return false;
      }
    } else {
      console.error(chalk.red('‚ùå Registration transaction failed'));
      console.log(`   Transaction hash: ${hash}`);
      return false;
    }

  } catch (error) {
    console.error(chalk.red('Registration failed:'), error.message);

    // Comprehensive error analysis
    const errorLower = error.message.toLowerCase();
    let recoverySteps = [];
    let canRetry = false;
    
    if (errorLower.includes('insufficient funds') || errorLower.includes('insufficient_funds')) {
      console.error(chalk.yellow('\nüí° Insufficient funds detected'));
      console.error(chalk.yellow('Registration requires 1 VANA + gas fees (~1.1 VANA total)'));
      recoverySteps = [
        'Check balance: https://moksha.vanascan.io/address/' + deployment.address,
        'Get testnet VANA: https://faucet.vana.org',
        'Wait 1-2 minutes for funds to arrive',
        'Retry registration: npm run register:datadao'
      ];
    } else if (errorLower.includes('user rejected') || errorLower.includes('user denied')) {
      console.error(chalk.yellow('\nüí° Transaction cancelled by user'));
      canRetry = true;
      recoverySteps = [
        'No action needed - you cancelled the transaction',
        'Retry when ready: npm run register:datadao'
      ];
    } else if (errorLower.includes('already registered') || errorLower.includes('dlp exists')) {
      console.error(chalk.yellow('\nüí° DataDAO may already be registered'));
      recoverySteps = [
        'Check registration on Vanascan: https://moksha.vanascan.io/address/' + dlpProxyAddress,
        'If registered, run: npm run status to update local state',
        'Otherwise, contact support with your DLP address'
      ];
    } else if (errorLower.includes('reverted') || errorLower.includes('execution failed')) {
      console.error(chalk.yellow('\nüí° Transaction was reverted by the network'));
      recoverySteps = [
        'Verify contract deployment succeeded: npm run status',
        'Check DLP proxy address is correct in deployment.json',
        'Ensure you\'re using the proxy address, not implementation',
        'Try manual registration via Vanascan'
      ];
    } else if (errorLower.includes('nonce') || errorLower.includes('already known')) {
      console.error(chalk.yellow('\nüí° Transaction nonce conflict detected'));
      canRetry = true;
      recoverySteps = [
        'Wait 30 seconds for pending transactions',
        'Check recent transactions: https://moksha.vanascan.io/address/' + deployment.address,
        'Retry registration: npm run register:datadao'
      ];
    } else if (errorLower.includes('timeout') || errorLower.includes('network')) {
      console.error(chalk.yellow('\nüí° Network connectivity issue'));
      canRetry = true;
      recoverySteps = [
        'Check your internet connection',
        'Wait 2-3 minutes for network congestion',
        'Retry registration: npm run register:datadao'
      ];
    } else {
      console.error(chalk.yellow('\nüí° Unexpected error occurred'));
      recoverySteps = [
        'Check the full error message above',
        'Verify deployment.json has correct addresses',
        'Try manual registration via Vanascan',
        'Contact support if issue persists'
      ];
    }
    
    // Display recovery steps
    console.error(chalk.cyan('\nüìã Recovery Steps:'));
    recoverySteps.forEach((step, index) => {
      console.error(chalk.white(`${index + 1}. ${step}`));
    });
    
    if (canRetry) {
      console.error(chalk.cyan('\nüîÑ This error is likely temporary and can be retried.'));
    }
    
    // Offer alternative registration method
    console.error(chalk.cyan('\nüåê Alternative: Manual Registration'));
    console.error(chalk.white('You can also register manually via Vanascan:'));
    console.error(chalk.blue('https://moksha.vanascan.io/address/{{DLP_REGISTRY_CONTRACT_ADDRESS}}?tab=write_proxy'));

    return false;
  }
}

/**
 * PRESERVED: Manual registration flow
 */
async function performManualRegistration(deployment) {
  // Get the DLP proxy address (supports both old and new format)
  const dlpProxyAddress = deployment.proxyAddress || 
                         (deployment.contracts && deployment.contracts.proxyAddress) ||
                         deployment.dlpAddress;
                         
  console.log();
  console.log(chalk.yellow('üîó Manual Registration Steps:'));
  console.log('1. Go to {{MOKSHA_BROWSER_URL}}/address/{{DLP_REGISTRY_CONTRACT_ADDRESS}}?tab=write_proxy');
  console.log('2. Connect your wallet');
  console.log('3. Find the "registerDlp" method');
  console.log('4. Fill in the registration info:');
  console.log(`   - dlpAddress: ${dlpProxyAddress}`);
  console.log(`   - ownerAddress: ${deployment.address}`);
  console.log(`   - treasuryAddress: ${deployment.address}`);
  console.log(`   - name: ${deployment.dlpName}`);
  console.log('   - iconUrl: (optional)');
  console.log('   - website: (optional)');
  console.log('   - metadata: (optional)');
  console.log('5. Set "Send native VANA" to 1 (click √ó10^18 button)');
  console.log('6. Submit the transaction');
  console.log();

  const { completed } = await inquirer.prompt([
    {
      type: 'confirm',
      name: 'completed',
      message: 'Have you completed the registration transaction?',
      default: false
    }
  ]);

  if (!completed) {
    console.log(chalk.yellow('Please complete the registration and run this script again.'));
    process.exit(0);
  }

  // Auto-detect dlpId after manual registration
  console.log();
  console.log(chalk.blue('üîç Detecting your dlpId...'));

  // Poll for dlpId (it might take a moment for the transaction to be processed)
  // Get the DLP proxy address (supports both old and new format)
  const dlpProxyAddress = deployment.proxyAddress || 
                         (deployment.contracts && deployment.contracts.proxyAddress) ||
                         deployment.dlpAddress;
                         
  let dlpId = 0;
  for (let i = 0; i < 10; i++) {
    dlpId = await getDlpId(dlpProxyAddress);
    if (dlpId > 0) break;

    console.log(`   Attempt ${i + 1}/10: Waiting for registration to be processed...`);
    await new Promise(resolve => setTimeout(resolve, 3000));
  }

  if (dlpId === 0) {
    console.error(chalk.red('Could not detect dlpId automatically.'));
    console.log(chalk.yellow('Please check your transaction and try again, or manually enter the dlpId.'));
    process.exit(1);
  }

  console.log(chalk.green(`‚úÖ dlpId detected: ${dlpId}`));
  deployment.dlpId = dlpId;
  deployment.state = deployment.state || {};
  deployment.state.dataDAORegistered = true;
  return true;
}

/**
 * Register DataDAO with BOTH automated AND manual options
 */
async function registerDataDAO() {
  console.log(chalk.blue('üìã DataDAO Registration'));
  console.log();

  // Load deployment info
  const deploymentPath = path.join(process.cwd(), 'deployment.json');
  if (!fs.existsSync(deploymentPath)) {
    console.error(chalk.red('No deployment.json found. Please deploy contracts first.'));
    process.exit(1);
  }

  const deployment = JSON.parse(fs.readFileSync(deploymentPath, 'utf8'));

  // Get the DLP proxy address (supports both old and new format)
  const dlpProxyAddress = deployment.proxyAddress || 
                         (deployment.contracts && deployment.contracts.proxyAddress) ||
                         deployment.dlpAddress;
                         
  if (!dlpProxyAddress) {
    console.error(chalk.red('No DLP proxy address found. Please deploy contracts first.'));
    process.exit(1);
  }

  console.log(chalk.blue('üìã Registration Information:'));
  console.log(`  DLP Address: ${dlpProxyAddress}`);
  console.log(`  Owner Address: ${deployment.address}`);
  console.log(`  DLP Name: ${deployment.dlpName}`);
  console.log();

  // Check if already registered
  console.log(chalk.blue('üîç Checking registration status...'));
  const existingDlpId = await getDlpId(dlpProxyAddress);

  if (existingDlpId > 0) {
    console.log(chalk.green(`‚úÖ DataDAO already registered with dlpId: ${existingDlpId}`));
    deployment.dlpId = existingDlpId;
    deployment.state = deployment.state || {};
    deployment.state.dataDAORegistered = true;
    fs.writeFileSync(deploymentPath, JSON.stringify(deployment, null, 2));

    console.log();
    console.log(chalk.blue('üéØ Your DataDAO is registered and ready!'));
    console.log('Next: Configure your proof template and refiner');
    return;
  }

  console.log(chalk.yellow('‚è∏Ô∏è  DataDAO not yet registered'));
  console.log();
  console.log(chalk.blue('üìã Registration Options:'));
  console.log();

  const { registrationMethod } = await inquirer.prompt([
    {
      type: 'list',
      name: 'registrationMethod',
      message: 'How would you like to register your DataDAO?',
      choices: [
        { name: '‚ö° Automated registration (recommended)', value: 'auto' },
        { name: 'üåê Manual registration via Vanascan', value: 'manual' },
        { name: '‚è∏Ô∏è  Skip for now', value: 'skip' }
      ]
    }
  ]);

  if (registrationMethod === 'skip') {
    console.log(chalk.yellow('Registration skipped. You can register later with: npm run register:datadao'));
    return;
  }

  let registrationSuccessful = false;

  if (registrationMethod === 'auto') {
    registrationSuccessful = await performAutomatedRegistration(deployment);
  } else if (registrationMethod === 'manual') {
    registrationSuccessful = await performManualRegistration(deployment);
  }

  if (registrationSuccessful) {
    fs.writeFileSync(deploymentPath, JSON.stringify(deployment, null, 2));
    console.log();
    console.log(chalk.green('‚úÖ DataDAO registration completed!'));
    console.log();
    console.log(chalk.blue('üéØ What happens next:'));
    console.log('‚Ä¢ Update your proof template with the dlpId');
    console.log('‚Ä¢ Get the encryption key for your refiner');
    console.log('‚Ä¢ Configure your proof-of-contribution logic');
    console.log('‚Ä¢ Test the full data contribution flow');
  } else if (registrationMethod === 'auto') {
    console.log();
    console.log(chalk.yellow('‚ö†Ô∏è  Automated registration failed'));
    console.log(chalk.yellow('You can try manual registration or run this script again'));
  }
}

// Run registration
registerDataDAO().catch(error => {
  console.error(chalk.red('Registration failed:'), error.message);
  process.exit(1);
}); 